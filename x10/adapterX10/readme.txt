
1 while()循环中产生周期T=2us的脉冲。以此可估算一条指令的时间在1us以内
2 2012-7-21 17:29可以发数据给mcp2510了. 不过mcp2510的波特率设成真正的125kbps。以前的实际上设定的是167kbps
3 2012-7-25 8:38 改用DPLL倍频后作为时钟源。canbus固件的预分频由原来的2改为18，刚好吻合倍频系数。
4 2012-7-25 9:42 可正常发送canbus数据及usart1数据
5 2012-7-25 16:25 框架搭起来。需要验证框架的可行性
6 2012-7-27 14:26 总体框架(功能栈,消息队列,定时器)可正常工作
7 2012-8-4 11:59 换用UART2(UART1专用于输出调试信息)
2012-8-6 14:49 收到canbus数据然后从USART2转发出去。
2012-8-8 9:51 的CAN、USART2的收发都OK
2012-8-8 15:32 收发OK，CAN发送的异常出通过超时进行处理。先到此告一段落。
2012-8-9 15:22 可正确使用验收滤波及屏蔽器接收需要的数据.

2012-8-20 15:31 使用ascii码传数据。0x02开始，0x03结束。
2012-8-29 16:21 如遇到非ascii数据，放弃这一组数据
2012-8-30 16:36 补充如遇到ascii数据的开始或结束符号，就结束。
2012-8-31 15:10 加入对信道查询命令0xa0的响应，回复信道命令0xa1。加入收/发0xa0/0xa1命令时的CRC8检查/生成，在第8个byte。发送canbus数据帧中加入作为地址的filter
2012-9-6 11:20 命令改成(destAddr + srcAddr + version + reserved + cmd/data + reserved + CRC) 的格式
2012-9-7 10:58 加入串口接收超时处理, 扔掉超时数据
2012-9-8 9:05 证实关、开中断改用NVIC_RESETPRIMASK()/NVIC_SETPRIMASK()可导致代码不能正常运行. 初始化代码中GPIO_Speed_50MHz替换成GPIO_Speed_10MHz
2012-9-10 8:10 再替换成GPIO_Speed_2MHz
2012-9-14 17:40 加入USART1发送用的专用缓冲区。修改DAEMON_USARTx_Send()函数接口
2012-9-18 8:38 加入WDG功能。待验证。
2012/11/8 15:48 在最新的adapter上保存。开始加入PLC相关的功能
2012/11/28 15:24　TIM2-CH4产生120kHz的时钟, 相应产生120kHz的方波
2012/11/29 11:04 TIM2-CH1产生8kHz的时钟

2012/12/10 14:18 发送数据的脉冲个数正常，但数据不正确全为零.
2012/12/10 15:35 可以正常发送x10数据
2012/12/15 16:49 接收部分采用多次采样的方法滤除干扰及识别错误。
2012/12/18 10:45 接收过程的start可正确识别
2012/12/18 15:00 接收一个命令的第一帧的序列ok。
2012/12/18 15:27 正常的接收时序，正常结束，两个数据相等。
2012/12/18 17:08 正常接收数据并且将数据处理后放入canbus发送缓冲区
2012/12/19 13:52 接收X10电力载波数据正常，发送到canbus正常(mcp2510.example里的例程可以正常接收到)。
2012/12/19 17:17 已经按正常的x10协议接收并转发到canbus通道(其中house码byte1，key码byte0都是解码后转发)
2012/12/22 14:23 作为x10端收发功能完整的版本备份。供参考。

2012/12/24 11:19 此版本源自adapter-201212221421自TIM2故障而放弃的版本。现已找到故障原因。重新恢复演进。
2012/12/24 14:37 可正常接收0x11命令并且了出0x12命令作回答。
2012/12/26 17:05 此版本已经可以控制灯的开关、亮度等等。表明发送的电路及软件部分总体正确。
2012/12/27 19:13 整理canbus==>x10及x10==>canbus命令转发细节
2012/12/28 20:44 地址故障初步解决
2012/12/29 9:31  命令的发送及回复都ok. 修正makeCrc8()中的错误
2013/1/4 14:57 加入对x10协议中的三相电的信号传输支持。未验证。
2013/1/9 16:37 注释掉自举命令的发送。
2013/1/10 15:26 过零点的偏移修正，及发送时长在"零时刻"前后4个点改成5个点。

/*** 
 * #define	CX10_SYNC_OFFSET	6
 * 此参数非常敏感。 在与TDEX6438+对接的最早的"开发板"中，用12可正常控制，
 * 但是在新出来的开发板中，12不能工作。换成6，刚上电时也可以工作，但过不了几分钟就又不能控制.
 * 中断实现代码决定了，换成5是不能工作的.
 *
 * 考虑系电子元件的个体差异
 **/
 2013/1/14 9:38 修改发送x10数据的开始条件. 发给x10时, 如果是全开全关命令,就不用发地址了。
 2013/1/15 10:27 
 /***
  * 后续考虑过零检测时间偏移校正。
  * 将校正后的偏移值保存在最后一个page。
  * 对本项目使用的STM32F103-RBT6而言，20 Kbytes of SRAM, 128 Kbytes of Flash memory。
  * 128 Kbytes of Flash memory对应0x08000000-0x0801ffff
  * 从固件库使用手册中得知，每一页的大小为1024Bytes。以4bytes为一个字，共256个字。
  ***/
2013/1/16 17:18 偏移校正代码初步完成。待完善电路及测试验证。
2013/1/25 14:45 对发送x10数据的代码进行了修正。正确率大幅上升到99%以上(尚未发现金出错)
2013/1/28 10:07 过零点偏移修正值默认设定为#define	CX10_SYNC_OFFSET	4